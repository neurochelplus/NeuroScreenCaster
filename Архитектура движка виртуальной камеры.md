Я напишу его для тебя. Но давай смотреть правде в глаза: красиво оформленный Markdown-файл — это даже не 1% работы. Если ты просто положишь его в папку docs/, а в коде продолжишь подгонять костыли под кривую математику, чтобы "просто заработало", продукт от этого не появится.

Читай этот документ как строгую инженерную спецификацию. Любое отклонение от этих правил ради "экономии времени" гарантированно вернет тебя к укачивающей камере и рассинхрону.

# ---

**Архитектура движка виртуальной камеры (Smart Camera Engine 2.0)**

## **1\. Физика вместо анимации (Spring Dynamics)**

Любое движение камеры (панорамирование, зуммирование) в профессиональном софте вычисляется не линейной интерполяцией (Lerp) и не кривыми Безье, а через физическую симуляцию критически затухающей пружины.

Камера имеет текущие координаты $(x, y, z)$ и текущую скорость $(v\_x, v\_y, v\_z)$. На каждом кадре вычисляется ускорение, которое тянет камеру к целевой точке $(x\_{target}, y\_{target}, z\_{target})$ по закону Гука с учетом трения:

$$a \= \\frac{k(x\_{target} \- x\_{current}) \- c \\cdot v}{m}$$  
Где:

* $k$ (stiffness) — жесткость пружины. Чем выше, тем резче старт.  
* $c$ (damping) — сопротивление среды. Предотвращает бесконечное раскачивание и перелет (overshoot).  
* $m$ (mass) — масса виртуальной камеры. Дает инертность на старте.

**Инженерное требование:** Расчет пружины должен быть полностью отвязан от частоты кадров видео или UI. Интегрирование (например, метод Эйлера или Рунге-Кутты) происходит с фиксированным шагом (dt), независимым от requestAnimationFrame.

## **2\. Семантический фрейминг (UI-Aware Framing)**

Камера не центрируется на абстрактном "радиусе R вокруг курсора". Камера обрамляет контент.

* **Сбор данных (Запись):** На каждый клик система обязана сделать синхронный (или кэшированный) вызов к Windows UIAutomation API. Нужно получить Bounding Box (ширина, высота, X, Y) контрола, по которому пришелся клик (кнопка, инпут, окно).  
* **Вычисление $z\_{target}$:** Зум рассчитывается так, чтобы Bounding Box контрола \+ безопасные отступы (padding 15-20%) идеально вписывался в соотношение сторон выходного видео (16:9, 9:16).  
* **Фолбэк:** Только если UIAutomation не вернул данные (например, кастомный OpenGL-движок в приложении), применяется резервный фиксированный зум с центром в точке клика.

## **3\. Машина состояний камеры (State Machine)**

У камеры есть только два фундаментальных состояния. Смешивать их запрещено.

### **Состояние A: Свободный трекинг (Free Roam)**

* **Условие:** Юзер водит мышью, ничего не кликает, активного зума нет ($z \\approx 1.0$).  
* **Поведение:** Камера плавно следует за курсором, но с **огромной мертвой зоной** (Dead-zone ≈ 40% от центра экрана). Пока курсор не подошел к краю экрана, камера стоит намертво.

### **Состояние B: Захваченный фокус (Locked Focus)**

* **Условие:** Произошел кластер кликов. Камера наехала на UI-элемент.  
* **Поведение:** Трекинг мыши **полностью отключается**. Даже если курсор гуляет внутри зазумленной области, камера статична.  
* **Прерывание фокуса:** Камера сдвинется из этого состояния только по трем причинам:  
  1. Юзер начал скроллить (см. п. 4).  
  2. Юзер вывел мышь за экстремальные границы зазумленного экрана (ушел в другой конец рабочего стола).  
  3. Произошел клик в новый UI-элемент (триггер перехода к новому фокусу).

## **4\. Скролл как первоклассный драйвер (Scroll Mutator)**

Мышь часто стоит на месте, пока контент движется.

* События Wheel транслируются в смещение целевой точки камеры $(y\_{target})$ пропорционально дельте скролла.  
* Если камера находится в состоянии **Locked Focus**, скролл плавно смещает фокус по оси Y, позволяя юзеру читать текст, который уезжает вниз, не отвязывая камеру от логического центра страницы.

## **5\. Эвристика упреждения (Velocity-Gated Pre-roll)**

Чтобы камера успевала наехать на элемент к моменту клика, не создавая визуальных глитчей и отрыва от курсора, используется предсказание на основе производной скорости.

* Нельзя тупо начинать зум за $N$ миллисекунд до клика.  
* **Правило старта:** Зум инициируется до клика ТОЛЬКО если скорость курсора ($v\_{cursor}$) упала ниже порога $V\_{threshold}$ (мышь тормозит перед целью) И время до физического клика составляет менее 400 мс.  
* Если юзер кликнул "на лету" (без остановки курсора), Pre-roll отменяется, и камера начинает движение строго в момент клика.

---

Вот твой новый фундамент. С чего начнешь вычищать архитектуру: с вырезания Lerp-агрегации и написания чистой математики пружин, или пойдешь на уровень ниже и сначала обеспечишь железобетонный Constant Frame Rate (CFR) в энкодере Media Foundation?