# **Технический план рефакторинга: От эвристики к "Умной Камере"**

## **Фундаментальная проблема текущего подхода**

Текущий конвейер (build\_auto\_zoom\_segments) работает линейно: Событие клика \-\> Проверка расстояния \-\> Создание статического квадрата. Это фатальная ошибка. Камера не знает, *что* она снимает, она знает только координаты.

**Цель:** Перейти к архитектуре на основе состояний (State-based Camera) и семантического контекста.

## **Фаза 1: Внедрение семантической кластеризации (Приоритет: Критический)**

Твоя система должна понимать иерархию UI. Если пользователь работает в одном окне, камера должна держать контекст этого окна.

**Что нужно изменить:**

1. **Переписать ClickSample:** Он должен хранить не просто focus\_rect, а полный UiContext.  
2. **Алгоритм cluster\_clicks:** \* **Убрать** жесткую привязку только к distance\_px.  
   * **Добавить** проверку контекста. Если два клика (даже на расстоянии 1000px) имеют одинаковый app\_name, и время между ними меньше context\_hold\_ms (например, 2-3 секунды), они **обязаны** попасть в один кластер.  
   * Вычислять union\_rect нужно так, чтобы он охватывал оба элемента, сохраняя логику интерфейса (например, панель инструментов слева и рабочую область справа).

**Новая структура данных (Rust):**

struct SemanticCluster {  
    app\_context: Option\<String\>,  
    events: Vec\<ClickSample\>,  
    bounds: RectPx, // Динамически расширяемый прямоугольник  
}

## **Фаза 2: Интеграция скроллинга (Приоритет: Критический)**

Если пользователь нажал на поле, сработал зум, а затем пользователь покрутил колесико — твоя текущая камера улетит в пустоту. Это убьет всё впечатление.

**Что нужно изменить:**

Зум-сегмент не может быть статичным target\_rect. Он должен поддерживать анимацию внутри самого себя (Pan-in-Zoom).

1. **Сборщик событий:** Убрать игнорирование InputEvent::Scroll.  
2. **Логика сегментации:**  
   * Когда формируется ZoomSegment, алгоритм должен просканировать все события Scroll между start\_ts и end\_ts.  
   * Если скролл обнаружен, генерируется траектория смещения (Pan Path).  
3. **Обновление ZoomSegment:**  
   Вместо статичного target\_rect: NormalizedRect, используй:

struct ZoomSegment {  
    id: String,  
    start\_ts: u64,  
    end\_ts: u64,  
    initial\_rect: NormalizedRect,  
    pan\_trajectory: Vec\<PanKeyframe\>, // Смещения от скролла  
    easing: ZoomEasing,  
}

## **Фаза 3: Векторная кинематика Lookahead (Приоритет: Высокий)**

Твои жесткие 600ms в lookahead\_ms — это костыль. Пользователь двигает мышью с разной скоростью. Если мышь летит быстро, камера должна начать отдаляться/приближаться раньше.

**Что нужно изменить:**

Написать функцию расчета "энергии" движения (Velocity Tracker).

1. Перед каждым кластером кликов бери точки курсора за последние 1000мс.  
2. Вычисляй среднюю скорость ![][image1] (пиксели/мс).  
3. Вычисляй динамический lookahead: dynamic\_lookahead \= base\_lookahead \+ (velocity \* factor).  
4. Чем быстрее движение к цели, тем раньше виртуальный оператор начинает движение камеры, чтобы мышь не "вылетала" за границы сужающегося кадра.

## **Фаза 4: Адаптивный и пропорциональный Padding (Приоритет: Средний)**

Текущие padding\_px: 80.0 уничтожают маленькие окна и душат большие. Отступы должны дышать.

**Что нужно изменить:**

Написать функцию calculate\_smart\_padding(rect, screen\_size).

1. Базовый паддинг — это процент от размера элемента, а не константа. Например, 15% от max(width, height).  
2. Внедрить ограничители (clamp): минимум 50px (чтобы элемент не прилипал к краю), максимум 300px (чтобы не показывать слишком много лишнего фона).  
3. **Сохранение пропорций (Aspect Ratio Lock):** Твоя камера должна возвращать target\_rect в пропорциях финального видео (обычно 16:9). Иначе при рендеринге в Remotion/композиторе рамка будет скакать по ширине и высоте, вызывая тошноту. Расширяй union\_rect до пропорций 16:9 *до* нормализации.

## **Пошаговый план действий (Action Plan)**

1. **Удали захардкоженные константы** из AutoZoomConfig. Сделай их функциями, зависящими от DPI и разрешения экрана. То, что работает на 1080p, будет выглядеть ужасно на 4K Retina.  
2. **Реализуй семантическую группировку.** Перепиши cluster\_clicks, добавив туда проверку ui\_context.  
3. **Напиши математику соотношения сторон (Aspect Ratio Ratio Enforcement).** target\_rect ВСЕГДА должен иметь соотношение 16:9 (или то, которое выбрал пользователь для проекта).  
4. **Добавь обработку Scroll.** Это самая сложная алгоритмическая часть. Начни с простого линейного смещения initial\_rect по оси Y в зависимости от накопленного delta.dy.

Хватит мыслить категориями "точка А и точка Б". Начинай мыслить как оператор: "Что я показываю?", "Куда сейчас переключится внимание?", "Как мне плавно провести зрителя за мыслью спикера?". Код должен отражать эти вопросы.

[image1]: <data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAYCAYAAADDLGwtAAAA/UlEQVR4XmNgGLxATk5uvoKCggOyQD02LC8vvx+I74MVycrKSgF1JQAl+qEYWeF/kGK4ibgASDG6GBWBsbExK9CKdqBbvgDd2gkUYgGJA9kWQLETSkpK/GCFQIEMoEArEC8F4odALAkSB2oOg/OlpKREgIztQKwIxNeB+CpIDGoZI5B/V1FRURxkmgJQZyrIOmhQtEIVgQGQvxWohANZDKTwN1CTDbIgukYGGRkZaaDgaaBCQSRhFnSNIIf7AnE5khAj0MoKJD4EAE3TBCqcD2QyQvlWQP4KNGVgAPLhNyA+AFSwEUhvA5ooga4IDEC+AyqQlJaWFmaAmjwsAQCIYzsq7unbwAAAAABJRU5ErkJggg==>